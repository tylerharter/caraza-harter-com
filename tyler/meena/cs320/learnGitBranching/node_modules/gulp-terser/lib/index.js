"use strict";

var _through = _interopRequireDefault(require("through2"));

var _terser = _interopRequireDefault(require("terser"));

var _pluginError = _interopRequireDefault(require("plugin-error"));

var _vinylSourcemapsApply = _interopRequireDefault(require("vinyl-sourcemaps-apply"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var PLUGIN_NAME = 'terser';
/**
 * @param { Object } defaultOption: gulp传递的配置
 * @return { Function }
 */

function gulpTerser() {
  var defaultOption = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // source-map option
  defaultOption.sourceMap = (defaultOption === null || defaultOption === void 0 ? void 0 : defaultOption.sourceMap) || {};

  var stream = _through.default.obj(function (file, enc, callback) {
    if (file.isStream()) {
      this.emit('error', new _pluginError.default(PLUGIN_NAME, 'Streams are not supported!'));
      return callback();
    }

    if (file.isBuffer()) {
      try {
        // terser option
        var option = _objectSpread({}, defaultOption);

        if (file.sourceMap) {
          option.sourceMap.filename = file.sourceMap.file;
        } // 配置需要兼容


        var str = file.contents.toString('utf8');
        var build
        /* string | Object */
        = {};

        if ('sourceMap' in file && 'file' in file.sourceMap) {
          build[file.sourceMap.file] = str;
        } else {
          build = str;
        } // 压缩代码


        var result = _terser.default.minify(build, option); // 输出报错信息


        if ('error' in result) {
          throw new Error(result.error.message);
        } // Buffer


        file.contents = 'from' in Buffer ? Buffer.from(result.code) : new Buffer(result.code); // 输出source-map

        if (file.sourceMap && result.map) {
          (0, _vinylSourcemapsApply.default)(file, result.map);
        }

        this.push(file);
        return callback();
      } catch (err) {
        this.emit('error', new _pluginError.default(PLUGIN_NAME, err));
        return callback();
      }
    }
  });

  return stream;
}

module.exports = gulpTerser;